<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Debugging Tools on Mesen Documentation</title><link>/debugging.html</link><description>Recent content in Debugging Tools on Mesen Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="/debugging/index.xml" rel="self" type="application/rss+xml"/><item><title>Debugger</title><link>/debugging/debugger.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/debugger.html</guid><description>The debugger is the main part of the debugging tools available in Mesen. This window displays the disassembled code, allows you to configure breakpoints, labels and watch values. It also contains a large number of options and smaller features &amp;ndash; all of which are described below.
General Usage Tips Most elements in the debugger&amp;rsquo;s interface have right-click menu options - make sure you explore the right-click options available in each list and window.</description></item><item><title>APU Viewer</title><link>/debugging/apuviewer.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/apuviewer.html</guid><description>The APU Viewer displays information about the APU&amp;rsquo;s channels. The internal flags of every channel are shown, as well as some additional information, such as the channel&amp;rsquo;s current frequency.
It can also be used to temporarily mute specific channels by unchecking them in the Channel Control section.</description></item><item><title>Assembler</title><link>/debugging/assembler.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/assembler.html</guid><description>The assembler allows writing new code, editing existing code and running arbitrary code.
Usage Code is assembled on-the-fly, with the resulting byte code being shown on the right.
Any compilation error will be shown in the list at the bottom &amp;ndash; double-click an error in the list to navigate to the line that caused it.
Once you are done editing the code, you can either Execute it, or Apply it. Executing the code will make it run in the $3000-$3FFF memory range (temporarely overriding the PPU&amp;rsquo;s normal behavior) and break the execution once the code is done executing.</description></item><item><title>Event Viewer</title><link>/debugging/eventviewer.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/eventviewer.html</guid><description>PPU View The Event Viewer&amp;rsquo;s PPU view allows you to visually check the timing at which various events (register read/writes, NMIs, IRQs, etc.) occur. This can be useful when trying to perform timing-critical mid-frame changes to the PPU, or to verify that PPU updates finish before vertical blank ends, etc.
The colors can be configured and it&amp;rsquo;s also possible to define breakpoints as marks to be shown on the Event Viewer.</description></item><item><title>Memory Tools</title><link>/debugging/memorytools.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/memorytools.html</guid><description>Memory Viewer The memory viewer offers read and write access to all types of ROM and RAM:
CPU Memory PPU Memory PRG ROM Work RAM Save RAM CHR ROM CHR RAM Nametable RAM Palette RAM Sprite / OAM RAM Secondary OAM RAM Note: Only memory types that are available for the currently loaded ROM will be shown in the dropdown.
Highlighting There are a number of highlighting/coloring options in the memory viewer.</description></item><item><title>Performance Profiler</title><link>/debugging/performanceprofiler.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/performanceprofiler.html</guid><description>The profiler automatically collects data about all function calls done by the code, as well as the number of clock cycles spent in each respective function.
Using the profiler makes it is easy to find the bottlenecks in a game&amp;rsquo;s code, which can help code optimization efforts.
If you are familiar with Visual Studio&amp;rsquo;s profiler, these columns should be familiar:
Call Count: The number of times this function was called during profiling Inclusive Time (Cyc): The amount of CPU cycles spent within this function (including the cycles spent by all functions called by this function) Inclusive Time (%): The relative portion of CPU time spent within this function (including the time spent by all functions called by this function) Exclusive Time (Cyc): The amount of CPU cycles spent within this function (functions called by this function are excluded) Exclusive Time (%): The relative portion of CPU time spent within this function (functions called by this function are excluded) Call Count: The number of times this function was called during profiling Use the Reset button to reset the profiler&amp;rsquo;s data &amp;ndash; use this when you want to profile a specific portion of the execution.</description></item><item><title>PPU Viewer</title><link>/debugging/ppuviewer.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/ppuviewer.html</guid><description>The PPU Viewer is a collection of tools allowing you to view/edit the current state of various parts of the PPU&amp;rsquo;s memory: nametable RAM, CHR ROM/RAM, palette RAM and OAM (sprite) RAM.
All tabs share some common settings:
Auto-refresh: Enabled by default, this makes the PPU viewer refresh at a rate of 15 FPS. Auto-refresh speed: Configures at what speed the PPU viewer will refresh itself (15/30/60 FPS) Show information overlay: When enabled, a mouse-over overlay is shown in the nametable/CHR/sprite viewers with information on the tile/sprite below the mouse cursor.</description></item><item><title>Script Window</title><link>/debugging/scriptwindow.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/scriptwindow.html</guid><description>The Script Window allows Lua scripting via a Mesen-specific API. Using this API, you can interact with the emulation core to perform a variety of things (e.g: logging, drawing, implementing an AI).
The code editor contains an autocomplete feature for all of Mesen&amp;rsquo;s API &amp;ndash; typing emu. will display an autocomplete popup displaying all available functions. Select a function in the list to see its parameters, return value and description.</description></item><item><title>Text Hooker</title><link>/debugging/texthooker.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/texthooker.html</guid><description>Text Hooker The text hooker&amp;rsquo;s main window scans the current screen for recognized characters and outputs the equivalent text on the right.
For games that split the screen, you can use the When emulation is running, show PPU data at scanline option at the bottom to capture the portion of the screen that you need.
To configure character mappings, see the Character Mappings section below.
Character Mappings This tab allows you to configure the mappings between CHR tiles and text characters.</description></item><item><title>Trace Logger</title><link>/debugging/tracelogger.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/tracelogger.html</guid><description>Basic Information The trace logger displays the execution log of the CPU. It can display the last 30,000 CPU instructions executed. Additionally, it is also possible to log these instructions to the disk by using the Start Logging button. Log files can rapidly grow in size (to several GBs worth of data in a few seconds), so it is recommended to log for the shortest amount of time needed.
Display Options A number of options that toggle the display of several elements exist: Registers, CPU Cycles, PPU Cycles, PPU Scanline, Show Effective Addresses, Byte Code, Frame Count, Additional Information (IRQ, NMI, etc.</description></item><item><title>Integration with compilers</title><link>/debugging/debuggerintegration.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/debuggerintegration.html</guid><description>When building homebrew software in assembly or C, it is possible to export the labels used in your code and import them into Mesen to simplify the debugging process. This allows the debugger to know which portions of the ROM correspond to which functions in your code, as well as display your code&amp;rsquo;s comments inside the debugger itself.
Integration with compilers CC65 / CA65 CC65/CA65 are able to produce .DBG files which can be imported into Mesen&amp;rsquo;s debugger.</description></item></channel></rss>