<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home on Mesen Documentation</title><link>/</link><description>Recent content in Home on Mesen Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Changelog</title><link>/apireference/changelog.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apireference/changelog.html</guid><description>Changes between 0.9.7 and 0.9.8 New Features New function to get a label&amp;rsquo;s current CPU address: getLabelAddress Changes between 0.9.6 and 0.9.7 No changes.
Changes between 0.9.5 and 0.9.6 New Features New event callback: scriptEnded. New functions to get PRG/CHR ROM offsets based on a CPU/PPU address: getPrgRomOffsetand getChrRomOffset. New function for use with the test runner mode: stop Changes The end address parameter for addMemoryCallbackand removeMemoryCallbackis now optional.</description></item><item><title>Audio Options</title><link>/configuration/audio.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/configuration/audio.html</guid><description>General Options Audio Device: Selects which device is used for audio output (e.g computer speakers, or a headset)
Sample Rate: Selects the sample rate for the audio output &amp;ndash; typically, computers output at 44,100Hz or 48,000Hz, so they usually offer the best sound quality.
Latency: This represents the length of the buffer used in audio processing. A smaller value results in less delay between the audio and video, however, depending on the hardware used, a value that is too small may cause sound problems.</description></item><item><title>Callbacks</title><link>/apireference/callbacks.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apireference/callbacks.html</guid><description>addEventCallback Syntax
emu.addEventCallback(function, type) Parameters
function - A Lua function.
type - Enum See eventType.
Return value
Returns an integer value that can be used to remove the callback by calling removeEventCallback.
Description
Registers a callback function to be called whenever the specified event occurs.
The callback function receives no parameters.
removeEventCallback Syntax
emu.removeEventCallback(reference, type) Parameters
reference - The value returned by the call to addEventCallback.
type - Enum See eventType.</description></item><item><title>Input Options</title><link>/configuration/input.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/configuration/input.html</guid><description>General Options Console Type: Selects which console to emulate for all input ports. The NES and Famicom have different accessories and some of the identical accessories (e.g the Zapper) have different behavior on a hardware level. If you want to connect Famicom-only accessories that plug into the Famicom&amp;rsquo;s expansion port, select Famicom.
Automatically configure controllers when loading a game: When enabled, when loading any game recognized by Mesen&amp;rsquo;s internal game database, the appropriate controllers will automatically be setup.</description></item><item><title>Video Options</title><link>/configuration/video.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/configuration/video.html</guid><description>General Options Scale: The scale determines the emulator window&amp;rsquo;s size - use integer factors (e.g: 2x, 3x, 4x) for best results.
Aspect Ratio: The NES' internal aspect ratio is almost square (Default (No Stretching)), but it used to be displayed on CRT TVs that had a rectangular picture. To simulate a CRT TV, you can use the Auto option - it will switch between NTSC and PAL aspect ratios depending on the game you are playing.</description></item><item><title>Emulation Options</title><link>/configuration/emulation.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/configuration/emulation.html</guid><description>General Options Emulation Speed: This configures the regular speed to use when emulating. This should normally be set to 100%.
Fast Forward Speed: This is the alternate speed that is used when the Fast Forward button is held down.
Rewind Speed: This configures the speed at which to rewind the gameplay when the Rewind button is held down.
Run Ahead: Run ahead allows the reduction of input lag by the number of frames specified.</description></item><item><title>Debugger</title><link>/debugging/debugger.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/debugger.html</guid><description>The debugger is the main part of the debugging tools available in Mesen. This window displays the disassembled code, allows you to configure breakpoints, labels and watch values. It also contains a large number of options and smaller features &amp;ndash; all of which are described below.
General Usage Tips Most elements in the debugger&amp;rsquo;s interface have right-click menu options - make sure you explore the right-click options available in each list and window.</description></item><item><title>Drawing</title><link>/apireference/drawing.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apireference/drawing.html</guid><description>Drawing basics All drawing-related functions share a few properties:
(x, y) coordinates must be between (0, 0) and (255, 239)
The &amp;ldquo;duration&amp;rdquo; is specified as a number of frames during which the drawing must remain on the screen. This defaults to 1 frame when unspecified, and draw calls will be permanent (until a call to clearScreen) if duration is set to 0.
Colors are integers in ARGB format:</description></item><item><title>Preferences</title><link>/configuration/preferences.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/configuration/preferences.html</guid><description>General Options Display Language: Selects in which language the UI is shown &amp;ndash; defaults the user&amp;rsquo;s default language.
Automatically check for updates: When enabled, Mesen will check for a new version of the emulator every time the emulator is started.
Only allow one instance of Mesen at a time: When enabled, only a single copy of Mesen can be opened at the same time. This is useful when using file associations to load games by double-clicking on the rom files.</description></item><item><title>APU Viewer</title><link>/debugging/apuviewer.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/apuviewer.html</guid><description>The APU Viewer displays information about the APU&amp;rsquo;s channels. The internal flags of every channel are shown, as well as some additional information, such as the channel&amp;rsquo;s current frequency.
It can also be used to temporarily mute specific channels by unchecking them in the Channel Control section.</description></item><item><title>Assembler</title><link>/debugging/assembler.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/assembler.html</guid><description>The assembler allows writing new code, editing existing code and running arbitrary code.
Usage Code is assembled on-the-fly, with the resulting byte code being shown on the right.
Any compilation error will be shown in the list at the bottom &amp;ndash; double-click an error in the list to navigate to the line that caused it.
Once you are done editing the code, you can either Execute it, or Apply it. Executing the code will make it run in the $3000-$3FFF memory range (temporarely overriding the PPU&amp;rsquo;s normal behavior) and break the execution once the code is done executing.</description></item><item><title>Event Viewer</title><link>/debugging/eventviewer.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/eventviewer.html</guid><description>PPU View The Event Viewer&amp;rsquo;s PPU view allows you to visually check the timing at which various events (register read/writes, NMIs, IRQs, etc.) occur. This can be useful when trying to perform timing-critical mid-frame changes to the PPU, or to verify that PPU updates finish before vertical blank ends, etc.
The colors can be configured and it&amp;rsquo;s also possible to define breakpoints as marks to be shown on the Event Viewer.</description></item><item><title>Memory Tools</title><link>/debugging/memorytools.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/memorytools.html</guid><description>Memory Viewer The memory viewer offers read and write access to all types of ROM and RAM:
CPU Memory PPU Memory PRG ROM Work RAM Save RAM CHR ROM CHR RAM Nametable RAM Palette RAM Sprite / OAM RAM Secondary OAM RAM Note: Only memory types that are available for the currently loaded ROM will be shown in the dropdown.
Highlighting There are a number of highlighting/coloring options in the memory viewer.</description></item><item><title>Emulation</title><link>/apireference/emulation.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apireference/emulation.html</guid><description>getState Syntax
emu.getState() Return value
Table Current emulation state with the following structure:
region: int, clockRate: int, cpu: { status: int, a: int, irqFlag: int, cycleCount: int (64-bit, unsigned), pc: int, y: int, x: int, sp: int, nmiFlag: bool }, ppu: { cycle: int, scanline: int, frameCount: int, control: { backgroundEnabled: bool, intensifyBlue: bool, intensifyRed: bool, backgroundPatternAddr: int, grayscale: bool, verticalWrite: bool, intensifyGreen: bool, nmiOnVBlank: bool, spritesEnabled: bool, spritePatternAddr: int, spriteMask: bool, largeSprites: bool, backgroundMask: bool }, status: {, spriteOverflow: bool, verticalBlank: bool, sprite0Hit: bool }, state: { status: int, lowBitShift: int, xScroll: int, highBitShift: int, videoRamAddr: int, control: int, mask: int, tmpVideoRamAddr: int, writeToggle: bool, spriteRamAddr: int } }, apu: { square1: { outputVolume: int, frequency: float, duty: int, period: int, enabled: bool, dutyPosition: int, sweepShift: int, sweepPeriod: int, sweepEnabled: bool, sweepNegate: bool envelope: { counter: int, loop: bool, divider: int, volume: int, startFlag: bool, constantVolume: bool }, lengthCounter: { halt: bool, counter: int, reloadValue: int } }, square2: { outputVolume: int, frequency: float, duty: int, period: int, enabled: bool, dutyPosition: int, sweepShift: int, sweepPeriod: int, sweepEnabled: bool, sweepNegate: bool, envelope: { counter: int, loop: bool, divider: int volume: int, startFlag: bool, constantVolume: bool }, lengthCounter: { halt: bool, counter: int, reloadValue: int } }, triangle: { outputVolume: int, frequency: float, sequencePosition: int, period: int, enabled: bool, lengthCounter: { halt: bool, counter: int, reloadValue: int } }, noise: { modeFlag: bool, enabled: bool, outputVolume: int, frequency: float, period: int, shiftRegister: int, envelope: { counter: int, loop: bool, divider: int, volume: int, startFlag: bool, constantVolume: bool }, lengthCounter: { halt: bool, counter: int, reloadValue: int } }, dmc: { sampleLength: int, irqEnabled: bool, loop: bool, outputVolume: int, bytesRemaining: int, sampleAddr: int, period: int, sampleRate: float }, frameCounter: { fiveStepMode: int, irqEnabled: int, sequencePosition: int } }, cart: { selectedPrgPages: array, chrRomSize: int, chrRamSize: int, prgPageCount: int, chrPageSize: int, selectedChrPages: array, chrPageCount: int, prgRomSize: int, prgPageSize: int, } Description</description></item><item><title>Performance Profiler</title><link>/debugging/performanceprofiler.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/performanceprofiler.html</guid><description>The profiler automatically collects data about all function calls done by the code, as well as the number of clock cycles spent in each respective function.
Using the profiler makes it is easy to find the bottlenecks in a game&amp;rsquo;s code, which can help code optimization efforts.
If you are familiar with Visual Studio&amp;rsquo;s profiler, these columns should be familiar:
Call Count: The number of times this function was called during profiling Inclusive Time (Cyc): The amount of CPU cycles spent within this function (including the cycles spent by all functions called by this function) Inclusive Time (%): The relative portion of CPU time spent within this function (including the time spent by all functions called by this function) Exclusive Time (Cyc): The amount of CPU cycles spent within this function (functions called by this function are excluded) Exclusive Time (%): The relative portion of CPU time spent within this function (functions called by this function are excluded) Call Count: The number of times this function was called during profiling Use the Reset button to reset the profiler&amp;rsquo;s data &amp;ndash; use this when you want to profile a specific portion of the execution.</description></item><item><title>Input</title><link>/apireference/input.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apireference/input.html</guid><description>getInput Syntax
emu.getInput(port) Parameters
port - Integer The port number to read (0 to 3)
Return value
Table A table containing the status of all 8 buttons.
Description
Returns a table containing the status of all 8 buttons: { a, b, select, start, up, down, left, right }
setInput Syntax
emu.setInput(port, input) Parameters
port - Integer The port number to apply the input to (0 to 3)
input - Table A table containing the state of some (or all) of the 8 buttons (same format as returned by getInput)</description></item><item><title>PPU Viewer</title><link>/debugging/ppuviewer.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/ppuviewer.html</guid><description>The PPU Viewer is a collection of tools allowing you to view/edit the current state of various parts of the PPU&amp;rsquo;s memory: nametable RAM, CHR ROM/RAM, palette RAM and OAM (sprite) RAM.
All tabs share some common settings:
Auto-refresh: Enabled by default, this makes the PPU viewer refresh at a rate of 15 FPS. Auto-refresh speed: Configures at what speed the PPU viewer will refresh itself (15/30/60 FPS) Show information overlay: When enabled, a mouse-over overlay is shown in the nametable/CHR/sprite viewers with information on the tile/sprite below the mouse cursor.</description></item><item><title>Logging</title><link>/apireference/logging.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apireference/logging.html</guid><description>displayMessage Syntax
emu.displayMessage(category, text) Parameters
category - String The category is the portion shown between brackets []
text - String Text to show on the screen
Return value
None
Description
Displays a message on the main window in the format &amp;ldquo;[category] text&amp;rdquo;
log Syntax
emu.log(text) Parameters
text - String Text to log
Return value
None
Description
Logs the given string in the script&amp;rsquo;s log window - useful for debugging scripts.</description></item><item><title>Script Window</title><link>/debugging/scriptwindow.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/scriptwindow.html</guid><description>The Script Window allows Lua scripting via a Mesen-specific API. Using this API, you can interact with the emulation core to perform a variety of things (e.g: logging, drawing, implementing an AI).
The code editor contains an autocomplete feature for all of Mesen&amp;rsquo;s API &amp;ndash; typing emu. will display an autocomplete popup displaying all available functions. Select a function in the list to see its parameters, return value and description.</description></item><item><title>Memory Access</title><link>/apireference/memoryaccess.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apireference/memoryaccess.html</guid><description>read / readWord Syntax
emu.read(address, type, signed = false) emu.readWord(address, type, signed = false) Parameters
address - Integer The address/offset to read from.
type - Enum The type of memory to read from. See memType.
signed - (optional) Boolean If true, the value returned will be interpreted as a signed value.
Return value
An 8-bit (read) or 16-bit (readWord) value.
Description
Reads a value from the specified memory type.</description></item><item><title>Text Hooker</title><link>/debugging/texthooker.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/texthooker.html</guid><description>Text Hooker The text hooker&amp;rsquo;s main window scans the current screen for recognized characters and outputs the equivalent text on the right.
For games that split the screen, you can use the When emulation is running, show PPU data at scanline option at the bottom to capture the portion of the screen that you need.
To configure character mappings, see the Character Mappings section below.
Character Mappings This tab allows you to configure the mappings between CHR tiles and text characters.</description></item><item><title>Trace Logger</title><link>/debugging/tracelogger.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/tracelogger.html</guid><description>Basic Information The trace logger displays the execution log of the CPU. It can display the last 30,000 CPU instructions executed. Additionally, it is also possible to log these instructions to the disk by using the Start Logging button. Log files can rapidly grow in size (to several GBs worth of data in a few seconds), so it is recommended to log for the shortest amount of time needed.
Display Options A number of options that toggle the display of several elements exist: Registers, CPU Cycles, PPU Cycles, PPU Scanline, Show Effective Addresses, Byte Code, Frame Count, Additional Information (IRQ, NMI, etc.</description></item><item><title>Integration with compilers</title><link>/debugging/debuggerintegration.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/debugging/debuggerintegration.html</guid><description>When building homebrew software in assembly or C, it is possible to export the labels used in your code and import them into Mesen to simplify the debugging process. This allows the debugger to know which portions of the ROM correspond to which functions in your code, as well as display your code&amp;rsquo;s comments inside the debugger itself.
Integration with compilers CC65 / CA65 CC65/CA65 are able to produce .DBG files which can be imported into Mesen&amp;rsquo;s debugger.</description></item><item><title>Miscellaneous</title><link>/apireference/misc.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apireference/misc.html</guid><description>Save States There are 2 separate save state APIs.
The first one is synchronous and uses the saveSavestate and loadSavestate functions. Its main restriction is that it can only be used inside &amp;ldquo;startFrame&amp;rdquo; or &amp;ldquo;cpuExec&amp;rdquo; callback functions.
The second API is asynchronous and uses an internally-managed &amp;ldquo;save slot&amp;rdquo; system to hold states in memory. It uses the following functions: saveSavestateAsync, loadSavestateAsync, getSavestateData and clearSavestateData.
saveSavestate Syntax
emu.saveSavestate() Return value</description></item><item><title>Enums</title><link>/apireference/enums.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/apireference/enums.html</guid><description>eventType Syntax
emu.eventType.[value] Values
reset = 0, Triggered when a soft reset occurs nmi = 1, Triggered when an nmi occurs irq = 2, Triggered when an irq occurs startFrame = 3, Triggered at the start of a frame (cycle 0, scanline -1) endFrame = 4, Triggered at the end of a frame (cycle 0, scanline 240) codeBreak = 5, Triggered when code execution breaks (e.g due to a breakpoint, etc.</description></item></channel></rss>